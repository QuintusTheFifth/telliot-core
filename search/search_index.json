{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Telliot's documentation \u00b6 Overview \u00b6 Telliot is a Python framework for interacting with the decentralized TellorX network. With Telliot, you (or your smart contract) can: Ask the TellorX Decentralized Oracle to answer a question (we call that tipping ) Submit answers to questions that other people (or smart contracts) ask. (we call that reporting . Reporters earn tips, but must stake TRB as collateral against incorrect answers) Look up historical answers. Help maintain the security of the TellorX network by disputing inaccurate answers and voting on other disputes. Of course, TellorX supports DeFi with questions such as \"What is the current price of Bitcoin in US Dollars?\" But that is just the beginning. TellorX also supports arbitrary questions and answers. Any question is OK, provided that the Tellor community can answer it with a reasonable degree of confidence (remember, Reporters may lose TRB if the network votes the answer incorrect!) Telliot Software \u00b6 The telliot software currently consists of two main python packages: Telliot Core This package provides core functionality and a plugin framework for use by other Telliot subpackages and custom data feeds. Telliot Feed Examples This package provides several working examples of data feeds that can be either customized or used directly. Scope \u00b6 Telliot aims to make it easier to ask questions in a format that the Oracle can understand, and specify the format (i.e. data structure) of the answers you would like to receive - so that the community can answer them more reliably. The TellorX network is open to everyone, and Telliot is just one way to access it. You can use all of Telliot, parts of it, or not use it at all. You can also make contributions to improve it. Warning Use Telliot at your own risk. It may have bugs! Bugs may cost you real money! If you find any, please submit an issue , or better yet create a pull request with a suggested fix.","title":"Home"},{"location":"#welcome-to-telliots-documentation","text":"","title":"Welcome to Telliot's documentation"},{"location":"#overview","text":"Telliot is a Python framework for interacting with the decentralized TellorX network. With Telliot, you (or your smart contract) can: Ask the TellorX Decentralized Oracle to answer a question (we call that tipping ) Submit answers to questions that other people (or smart contracts) ask. (we call that reporting . Reporters earn tips, but must stake TRB as collateral against incorrect answers) Look up historical answers. Help maintain the security of the TellorX network by disputing inaccurate answers and voting on other disputes. Of course, TellorX supports DeFi with questions such as \"What is the current price of Bitcoin in US Dollars?\" But that is just the beginning. TellorX also supports arbitrary questions and answers. Any question is OK, provided that the Tellor community can answer it with a reasonable degree of confidence (remember, Reporters may lose TRB if the network votes the answer incorrect!)","title":"Overview"},{"location":"#telliot-software","text":"The telliot software currently consists of two main python packages: Telliot Core This package provides core functionality and a plugin framework for use by other Telliot subpackages and custom data feeds. Telliot Feed Examples This package provides several working examples of data feeds that can be either customized or used directly.","title":"Telliot Software"},{"location":"#scope","text":"Telliot aims to make it easier to ask questions in a format that the Oracle can understand, and specify the format (i.e. data structure) of the answers you would like to receive - so that the community can answer them more reliably. The TellorX network is open to everyone, and Telliot is just one way to access it. You can use all of Telliot, parts of it, or not use it at all. You can also make contributions to improve it. Warning Use Telliot at your own risk. It may have bugs! Bugs may cost you real money! If you find any, please submit an issue , or better yet create a pull request with a suggested fix.","title":"Scope"},{"location":"contributing/","text":"Contributing \u00b6 Development Environment Setup \u00b6 These instructions assume that a working Python interpreter (version >=3.8) is already installed on the system. Clone the repository to a local working directory: git clone https://github.com/tellor-io/telliot-core.git Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Linux Windows python3 -m venv tenv source tenv/bin/activate py -m venv tenv tenv\\Scripts\\activate If working on Ubuntu, may need to install one of the following packages ( see this issue ). sudo apt install libpython3.8-dev sudo apt install libpython3.9-dev Install the project using using an editable installation . pip install -e . pip install -r requirements-dev.txt Test Environment \u00b6 Verify the development environment by running pytest and ensure that all tests pass. pytest Making Contributions \u00b6 Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run all unit tests: pytest Check code typing: tox -e typing Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #telliot-core channel in the community discord for updates.","title":"Developer's Guide"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#development-environment-setup","text":"These instructions assume that a working Python interpreter (version >=3.8) is already installed on the system. Clone the repository to a local working directory: git clone https://github.com/tellor-io/telliot-core.git Create and activate a virtual environment . In this example, the virtual environment is located in a subfolder called tenv : Linux Windows python3 -m venv tenv source tenv/bin/activate py -m venv tenv tenv\\Scripts\\activate If working on Ubuntu, may need to install one of the following packages ( see this issue ). sudo apt install libpython3.8-dev sudo apt install libpython3.9-dev Install the project using using an editable installation . pip install -e . pip install -r requirements-dev.txt","title":"Development Environment Setup"},{"location":"contributing/#test-environment","text":"Verify the development environment by running pytest and ensure that all tests pass. pytest","title":"Test Environment"},{"location":"contributing/#making-contributions","text":"Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run all unit tests: pytest Check code typing: tox -e typing Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #telliot-core channel in the community discord for updates.","title":"Making Contributions"},{"location":"documentation/","text":"Project Documentation \u00b6 Telliot is documented using Material for MkDocs . The latest telliot-core documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve","title":"Documentation"},{"location":"documentation/#project-documentation","text":"Telliot is documented using Material for MkDocs . The latest telliot-core documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve","title":"Project Documentation"},{"location":"getting-started/","text":"Getting Started \u00b6 Telliot Configuration \u00b6 After installation of the telliot-core or any telliot data feeds, Telliot must be personalized to use your own private keys and endpoints. First, create the default configuration files: telliot config init The default configuration files are created in a folder called telliot in the user home folder: Saved config 'main' to ~/telliot/main.yaml Saved config 'endpoints' to ~/telliot/endpoints.yaml Saved config 'chains' to ~/telliot/chains.json To show the current configuration: telliot config show Main Configuration File \u00b6 The main configuration file allows you to choose which network Telliot will interact with. By default, Telliot is configured to run on Rinkeby testnet, as shown in the example below. Edit the ~/telliot/main.yaml config file for the desired configuration. To run on Etherium mainnet, use chain_id: 1 and network: mainnet . To submit values to the Tellor oracle, a private_key must also be configured. Example main configuration file: type : MainConfig loglevel : INFO chain_id : 4 network : rinkeby private_key : '' Configure endpoints \u00b6 Edit ~/telliot/endpoints.yaml to configure Telliot to use your own endpoints. If you don't have an endpoint, a free one is available at Infura.io . Simply replace INFURA_API_KEY with the one provided by Infura. Endpoints should be configured for both Etherium mainnet and Rinkeby testnet. Warning All telliot software and reporter feeds should be validated on Rinkeby prior to deploying on mainnet. Note that endpoints must use the websocket protocol because HTTPS endpoints do not support event listeners. Example endpoints.yaml file: type : EndpointList endpoints : - type : RPCEndpoint chain_id : 1 network : mainnet provider : Infura url : wss://mainnet.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://etherscan.io - type : RPCEndpoint chain_id : 4 network : rinkeby provider : Infura url : wss://rinkeby.infura.io/ws/v3{INFURA_API_KEY} explorer : https://rinkeby.etherscan.io","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#telliot-configuration","text":"After installation of the telliot-core or any telliot data feeds, Telliot must be personalized to use your own private keys and endpoints. First, create the default configuration files: telliot config init The default configuration files are created in a folder called telliot in the user home folder: Saved config 'main' to ~/telliot/main.yaml Saved config 'endpoints' to ~/telliot/endpoints.yaml Saved config 'chains' to ~/telliot/chains.json To show the current configuration: telliot config show","title":"Telliot Configuration"},{"location":"getting-started/#main-configuration-file","text":"The main configuration file allows you to choose which network Telliot will interact with. By default, Telliot is configured to run on Rinkeby testnet, as shown in the example below. Edit the ~/telliot/main.yaml config file for the desired configuration. To run on Etherium mainnet, use chain_id: 1 and network: mainnet . To submit values to the Tellor oracle, a private_key must also be configured. Example main configuration file: type : MainConfig loglevel : INFO chain_id : 4 network : rinkeby private_key : ''","title":"Main Configuration File"},{"location":"getting-started/#configure-endpoints","text":"Edit ~/telliot/endpoints.yaml to configure Telliot to use your own endpoints. If you don't have an endpoint, a free one is available at Infura.io . Simply replace INFURA_API_KEY with the one provided by Infura. Endpoints should be configured for both Etherium mainnet and Rinkeby testnet. Warning All telliot software and reporter feeds should be validated on Rinkeby prior to deploying on mainnet. Note that endpoints must use the websocket protocol because HTTPS endpoints do not support event listeners. Example endpoints.yaml file: type : EndpointList endpoints : - type : RPCEndpoint chain_id : 1 network : mainnet provider : Infura url : wss://mainnet.infura.io/ws/v3/{INFURA_API_KEY} explorer : https://etherscan.io - type : RPCEndpoint chain_id : 4 network : rinkeby provider : Infura url : wss://rinkeby.infura.io/ws/v3{INFURA_API_KEY} explorer : https://rinkeby.etherscan.io","title":"Configure endpoints"},{"location":"code/datafeed/","text":"DataSource ( Generic , Base ) dataclass \u00b6 Base Class for a DataSource A DataSource provides an input to a DataFeed It also contains a store for all previously fetched data points. All subclasses must implement DataSource.fetch_new_datapoint() latest : Tuple [ Union [ ~ T , NoneType ], Union [ datetime . datetime ]] property readonly \u00b6 Returns the most recent datapoint or none if history is empty store_datapoint ( self , datapoint ) \u00b6 Store a datapoint Source code in telliot_core\\datasource.py def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint ) get_all_datapoints ( self ) \u00b6 Get a list of all available data points Source code in telliot_core\\datasource.py def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history ) fetch_new_datapoint ( self ) async \u00b6 Fetch new value and store it for later retrieval Source code in telliot_core\\datasource.py async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError DataFeed ( Generic , Base ) dataclass \u00b6 Data feed providing query response A data feed contains a DataSource to fetch values in response to an OracleQuery . Attributes: Name Type Description query OracleQuery The Query that this feed responds to source telliot_core.datasource.DataSource[~T] Data source for feed","title":"Data Feed Module"},{"location":"code/datafeed/#telliot_core.datasource.DataSource","text":"Base Class for a DataSource A DataSource provides an input to a DataFeed It also contains a store for all previously fetched data points. All subclasses must implement DataSource.fetch_new_datapoint()","title":"DataSource"},{"location":"code/datafeed/#telliot_core.datasource.DataSource.latest","text":"Returns the most recent datapoint or none if history is empty","title":"latest"},{"location":"code/datafeed/#telliot_core.datasource.DataSource.store_datapoint","text":"Store a datapoint Source code in telliot_core\\datasource.py def store_datapoint ( self , datapoint : DataPoint [ T ]) -> None : \"\"\"Store a datapoint\"\"\" v , t = datapoint if v is not None and t is not None : self . _history . append ( datapoint )","title":"store_datapoint()"},{"location":"code/datafeed/#telliot_core.datasource.DataSource.get_all_datapoints","text":"Get a list of all available data points Source code in telliot_core\\datasource.py def get_all_datapoints ( self ) -> List [ DataPoint [ T ]]: \"\"\"Get a list of all available data points\"\"\" return list ( self . _history )","title":"get_all_datapoints()"},{"location":"code/datafeed/#telliot_core.datasource.DataSource.fetch_new_datapoint","text":"Fetch new value and store it for later retrieval Source code in telliot_core\\datasource.py async def fetch_new_datapoint ( self ) -> OptionalDataPoint [ T ]: \"\"\"Fetch new value and store it for later retrieval\"\"\" raise NotImplementedError","title":"fetch_new_datapoint()"},{"location":"code/datafeed/#telliot_core.datafeed.DataFeed","text":"Data feed providing query response A data feed contains a DataSource to fetch values in response to an OracleQuery . Attributes: Name Type Description query OracleQuery The Query that this feed responds to source telliot_core.datasource.DataSource[~T] Data source for feed","title":"DataFeed"},{"location":"code/queries/","text":"OracleQuery ( Serializable ) \u00b6 Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent an input that can be used to customize the query. The base class provides: Calculation of the contents of the data field to include with the TellorX.Oracle.tipQuery() contract call. Calculation of the id field field to include with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. descriptor : str property readonly \u00b6 Get the query descriptor string. The Query descriptor is a unique string representation of the query. The descriptor is required for users to specify the query to TellorX through the TellorX.Oracle.tipQuery() contract call. value_type : ValueType property readonly \u00b6 Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be overridden by subclasses query_data : bytes property readonly \u00b6 Returns the data field for use in TellorX.Oracle.tipQuery() contract call. query_id : bytes property readonly \u00b6 Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. SpotPrice ( OracleQuery ) dataclass \u00b6 Returns the spot price of a cryptocurrency asset in the given currency. Attributes: Name Type Description asset str Asset ID (see data specifications for a full list of supported assets) currency str Currency (default = usd ) value_type : ValueType property readonly \u00b6 Data type returned for a SpotPrice query. ufixed256x18 : 256-bit unsigned integer with 18 decimals of precision packed : false LegacyRequest ( OracleQuery ) dataclass \u00b6 Legacy Price/Value request Legacy request are queries that existed prior to TellorX A legacy query uses arbitrary query data and a static query id . The query id is always set to the legacy request ID, which is a static integer less than 100. The LegacyQuery class is deprecated and should not be used by new projects. Refer to tellor documentation for a description of each id value_type : ValueType property readonly \u00b6 Returns the Legacy Value Type for all legacy queries query_id : bytes property readonly \u00b6 Override query id with the legacy request ID. StringQuery ( OracleQuery ) dataclass \u00b6 Static Oracle Query A text query supports a question in the form of an arbitrary text. value_type : ValueType property readonly \u00b6 Returns a default text response type.","title":"Queries Module"},{"location":"code/queries/#telliot_core.queries.query.OracleQuery","text":"Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent an input that can be used to customize the query. The base class provides: Calculation of the contents of the data field to include with the TellorX.Oracle.tipQuery() contract call. Calculation of the id field field to include with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls.","title":"OracleQuery"},{"location":"code/queries/#telliot_core.queries.query.OracleQuery.descriptor","text":"Get the query descriptor string. The Query descriptor is a unique string representation of the query. The descriptor is required for users to specify the query to TellorX through the TellorX.Oracle.tipQuery() contract call.","title":"descriptor"},{"location":"code/queries/#telliot_core.queries.query.OracleQuery.value_type","text":"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be overridden by subclasses","title":"value_type"},{"location":"code/queries/#telliot_core.queries.query.OracleQuery.query_data","text":"Returns the data field for use in TellorX.Oracle.tipQuery() contract call.","title":"query_data"},{"location":"code/queries/#telliot_core.queries.query.OracleQuery.query_id","text":"Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls.","title":"query_id"},{"location":"code/queries/#telliot_core.queries.price.spot_price.SpotPrice","text":"Returns the spot price of a cryptocurrency asset in the given currency. Attributes: Name Type Description asset str Asset ID (see data specifications for a full list of supported assets) currency str Currency (default = usd )","title":"SpotPrice"},{"location":"code/queries/#telliot_core.queries.price.spot_price.SpotPrice.value_type","text":"Data type returned for a SpotPrice query. ufixed256x18 : 256-bit unsigned integer with 18 decimals of precision packed : false","title":"value_type"},{"location":"code/queries/#telliot_core.queries.legacy_query.LegacyRequest","text":"Legacy Price/Value request Legacy request are queries that existed prior to TellorX A legacy query uses arbitrary query data and a static query id . The query id is always set to the legacy request ID, which is a static integer less than 100. The LegacyQuery class is deprecated and should not be used by new projects. Refer to tellor documentation for a description of each id","title":"LegacyRequest"},{"location":"code/queries/#telliot_core.queries.legacy_query.LegacyRequest.value_type","text":"Returns the Legacy Value Type for all legacy queries","title":"value_type"},{"location":"code/queries/#telliot_core.queries.legacy_query.LegacyRequest.query_id","text":"Override query id with the legacy request ID.","title":"query_id"},{"location":"code/queries/#telliot_core.queries.string_query.StringQuery","text":"Static Oracle Query A text query supports a question in the form of an arbitrary text.","title":"StringQuery"},{"location":"code/queries/#telliot_core.queries.string_query.StringQuery.value_type","text":"Returns a default text response type.","title":"value_type"},{"location":"code/types/","text":"ValueType ( Serializable ) dataclass \u00b6 Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html encode ( self , value ) \u00b6 Encode a value using the ABI Type string. Source code in telliot_core\\types\\value_type.py def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) decode ( self , bytes_val ) \u00b6 Decode bytes into a value using abi type string. Source code in telliot_core\\types\\value_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val ) UnsignedFloatType ( ValueType ) dataclass \u00b6 Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. decimals : int property readonly \u00b6 Get precision from abi type nbits : int property readonly \u00b6 Get number of bits from abi type encode ( self , value ) \u00b6 An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. Source code in telliot_core\\types\\float_type.py def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) decode ( self , bytes_val ) \u00b6 A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. Source code in telliot_core\\types\\float_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"Types Module"},{"location":"code/types/#telliot_core.types.value_type.ValueType","text":"Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html","title":"ValueType"},{"location":"code/types/#telliot_core.types.value_type.ValueType.encode","text":"Encode a value using the ABI Type string. Source code in telliot_core\\types\\value_type.py def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value )","title":"encode()"},{"location":"code/types/#telliot_core.types.value_type.ValueType.decode","text":"Decode bytes into a value using abi type string. Source code in telliot_core\\types\\value_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val )","title":"decode()"},{"location":"code/types/#telliot_core.types.float_type.UnsignedFloatType","text":"Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values.","title":"UnsignedFloatType"},{"location":"code/types/#telliot_core.types.float_type.UnsignedFloatType.decimals","text":"Get precision from abi type","title":"decimals"},{"location":"code/types/#telliot_core.types.float_type.UnsignedFloatType.nbits","text":"Get number of bits from abi type","title":"nbits"},{"location":"code/types/#telliot_core.types.float_type.UnsignedFloatType.encode","text":"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. Source code in telliot_core\\types\\float_type.py def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the SpotPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value )","title":"encode()"},{"location":"code/types/#telliot_core.types.float_type.UnsignedFloatType.decode","text":"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. Source code in telliot_core\\types\\float_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the SpotPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"decode()"},{"location":"examples/legacy_query_example/","text":"Legacy Query Example \u00b6 This example demonstrates how to create a LegacyRequest requesting the ETH/USD price. The legacy request ID for ETH/USD is 1 , in accordance with the Legacy Data Feed ID Specifications . Create the query \u00b6 Create a LegacyQuery and view the corresponding query descriptor: from telliot_core.queries import LegacyRequest q = LegacyRequest ( legacy_id = 1 ) print ( q . descriptor ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"LegacyRequest\" , \"legacy_id\" : 1 } On-chain representation \u00b6 To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the LegacyQuery object: print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a224c656761637952657175657374222c226c65676163795f6964223a317d tipQuery ID: 0x0000000000000000000000000000000000000000000000000000000000000001 Response encoding/decoding \u00b6 The LegacyQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the value 10000.1234567 , use the encode and decode methods of the response ValueType . value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (float): 10000.1234567 submitValue (bytes): 0x00000000000000000000000000000000000000000000000000000002540dc641 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 10000.123457 Full Example \u00b6 The full example is provided here for reference \"\"\"Legacy Query Example \"\"\" from telliot_core.queries import LegacyRequest q = LegacyRequest ( legacy_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"Legacy Query"},{"location":"examples/legacy_query_example/#legacy-query-example","text":"This example demonstrates how to create a LegacyRequest requesting the ETH/USD price. The legacy request ID for ETH/USD is 1 , in accordance with the Legacy Data Feed ID Specifications .","title":"Legacy Query Example"},{"location":"examples/legacy_query_example/#create-the-query","text":"Create a LegacyQuery and view the corresponding query descriptor: from telliot_core.queries import LegacyRequest q = LegacyRequest ( legacy_id = 1 ) print ( q . descriptor ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"LegacyRequest\" , \"legacy_id\" : 1 }","title":"Create the query"},{"location":"examples/legacy_query_example/#on-chain-representation","text":"To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the LegacyQuery object: print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a224c656761637952657175657374222c226c65676163795f6964223a317d tipQuery ID: 0x0000000000000000000000000000000000000000000000000000000000000001","title":"On-chain representation"},{"location":"examples/legacy_query_example/#response-encodingdecoding","text":"The LegacyQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the value 10000.1234567 , use the encode and decode methods of the response ValueType . value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (float): 10000.1234567 submitValue (bytes): 0x00000000000000000000000000000000000000000000000000000002540dc641 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 10000.123457","title":"Response encoding/decoding"},{"location":"examples/legacy_query_example/#full-example","text":"The full example is provided here for reference \"\"\"Legacy Query Example \"\"\" from telliot_core.queries import LegacyRequest q = LegacyRequest ( legacy_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"Full Example"},{"location":"examples/spot_price_query_example/","text":"Spot Price Query Example \u00b6 This example demonstrates how to use the SpotPrice Oracle query. Create the query \u00b6 Create a SpotPrice query for the price of Bitcoin in US dollars, and view the corresponding descriptor:: from telliot_core.queries import SpotPrice q = SpotPrice ( asset = 'btc' , currency = 'usd' ) print ( q . descriptor ) The query .descriptor attribute returns a unique string that identifies this query to the TellorX Oracle network: { \"type\" : \"SpotPrice\" , \"asset\" : \"btc\" , \"currency\" : \"usd\" } On-chain representation \u00b6 To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are computed solely from the query descriptor , and are provided by the query_data and query_id attributes as a convenience. print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a2253706f745072696365222c226173736574223a22627463222c2263757272656e6379223a22757364227d tipQuery ID: 0xd66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a Response encoding/decoding \u00b6 The SpotPrice query can also be used to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the real world value 99.9 use the ValueType . encode method. value = 99.99 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) submitValue (float): 99.99 submitValue (bytes): 0x0000000000000000000000000000000000000000000000056ba3d73af34eec04 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 99.99 Full Example \u00b6 The full example is provided here for reference \"\"\"Text Query Example \"\"\" from telliot_core.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"SpotPrice Query"},{"location":"examples/spot_price_query_example/#spot-price-query-example","text":"This example demonstrates how to use the SpotPrice Oracle query.","title":"Spot Price Query Example"},{"location":"examples/spot_price_query_example/#create-the-query","text":"Create a SpotPrice query for the price of Bitcoin in US dollars, and view the corresponding descriptor:: from telliot_core.queries import SpotPrice q = SpotPrice ( asset = 'btc' , currency = 'usd' ) print ( q . descriptor ) The query .descriptor attribute returns a unique string that identifies this query to the TellorX Oracle network: { \"type\" : \"SpotPrice\" , \"asset\" : \"btc\" , \"currency\" : \"usd\" }","title":"Create the query"},{"location":"examples/spot_price_query_example/#on-chain-representation","text":"To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are computed solely from the query descriptor , and are provided by the query_data and query_id attributes as a convenience. print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a2253706f745072696365222c226173736574223a22627463222c2263757272656e6379223a22757364227d tipQuery ID: 0xd66b36afdec822c56014e56f468dee7c7b082ed873aba0f7663ec7c6f25d2c0a","title":"On-chain representation"},{"location":"examples/spot_price_query_example/#response-encodingdecoding","text":"The SpotPrice query can also be used to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the real world value 99.9 use the ValueType . encode method. value = 99.99 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) submitValue (float): 99.99 submitValue (bytes): 0x0000000000000000000000000000000000000000000000056ba3d73af34eec04 Similarly, the decode method can be used to convert the on-chain bytes value to a real-world value: decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Decoded value (float): 99.99","title":"Response encoding/decoding"},{"location":"examples/spot_price_query_example/#full-example","text":"The full example is provided here for reference \"\"\"Text Query Example \"\"\" from telliot_core.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" )","title":"Full Example"},{"location":"examples/text_query_example/","text":"Text Query Example \u00b6 The following example demonstrates how to create a StringQuery request. Create a StringQuery and view the corresponding query descriptor:: \"\"\"Text Query Example \"\"\" from telliot_core.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"StringQuery\" , \"text\" : \"What is the meaning of life?\" } To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the StringQuery object: \"\"\"Text Query Example \"\"\" from telliot_core.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a22537472696e675175657279222c2274657874223a225768617420697320746865206d65616e696e67206f66206c6966653f227d tipQuery ID: 0xdd349fc565b13987a11bed4cc9e7382863491638769020afad1abe3840ec14b7 The StringQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit following the answer Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life use the encode and decode methods of the response ValueType . \"\"\"Text Query Example \"\"\" from telliot_core.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (str): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life submitValue (bytes): 0x000000000000000000000000000000000000000000000000000000000000003e506c6561736520726566657220746f3a2068747470733a2f2f656e2e77696b6970656469612e6f72672f77696b692f4d65616e696e675f6f665f6c6966650000 Decoded value (float): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life","title":"Text Query"},{"location":"examples/text_query_example/#text-query-example","text":"The following example demonstrates how to create a StringQuery request. Create a StringQuery and view the corresponding query descriptor:: \"\"\"Text Query Example \"\"\" from telliot_core.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"StringQuery\" , \"text\" : \"What is the meaning of life?\" } To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the StringQuery object: \"\"\"Text Query Example \"\"\" from telliot_core.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a22537472696e675175657279222c2274657874223a225768617420697320746865206d65616e696e67206f66206c6966653f227d tipQuery ID: 0xdd349fc565b13987a11bed4cc9e7382863491638769020afad1abe3840ec14b7 The StringQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit following the answer Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life use the encode and decode methods of the response ValueType . \"\"\"Text Query Example \"\"\" from telliot_core.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (str): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life submitValue (bytes): 0x000000000000000000000000000000000000000000000000000000000000003e506c6561736520726566657220746f3a2068747470733a2f2f656e2e77696b6970656469612e6f72672f77696b692f4d65616e696e675f6f665f6c6966650000 Decoded value (float): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life","title":"Text Query Example"}]}