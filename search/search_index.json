{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Telliot's documentation \u00b6 Overview \u00b6 Telliot is a Python framework for interacting with the decentralized TellorX network. With Telliot, you (or your smart contract) can: Ask the TellorX Decentralized Oracle to answer a question (we call that tipping ) Submit answers to questions that other people (or smart contracts) ask. (we call that reporting . Reporters earn tips, but must stake TRB as collateral against incorrect answers) Look up historical answers. Help maintain the security of the TellorX network by disputing inaccurate answers and voting on other disputes. Of course, TellorX supports DeFi with questions such as \"What is the current price of Bitcoin in US Dollars?\" But that is just the beginning. TellorX also supports arbitrary questions and answers. Any question is OK, provided that the Tellor community can answer it with a reasonable degree of confidence (remember, Reporters may lose TRB if the network votes the answer incorrect!) Scope \u00b6 Telliot aims to make it easier to ask questions in a format that the Oracle can understand, and specify the format (i.e. data structure) of the answers you would like to receive - so that the community can answer them more reliably. The TellorX network is open to everyone, and Telliot is just one way to access it. You can use all of Telliot, parts of it, or not use it at all. You can also make contributions to improve it. Warning Use Telliot at your own risk. It may have bugs! Bugs may cost you real money! If you find any, please submit an issue , or better yet create a pull request with a suggested fix.","title":"Home"},{"location":"#welcome-to-telliots-documentation","text":"","title":"Welcome to Telliot's documentation"},{"location":"#overview","text":"Telliot is a Python framework for interacting with the decentralized TellorX network. With Telliot, you (or your smart contract) can: Ask the TellorX Decentralized Oracle to answer a question (we call that tipping ) Submit answers to questions that other people (or smart contracts) ask. (we call that reporting . Reporters earn tips, but must stake TRB as collateral against incorrect answers) Look up historical answers. Help maintain the security of the TellorX network by disputing inaccurate answers and voting on other disputes. Of course, TellorX supports DeFi with questions such as \"What is the current price of Bitcoin in US Dollars?\" But that is just the beginning. TellorX also supports arbitrary questions and answers. Any question is OK, provided that the Tellor community can answer it with a reasonable degree of confidence (remember, Reporters may lose TRB if the network votes the answer incorrect!)","title":"Overview"},{"location":"#scope","text":"Telliot aims to make it easier to ask questions in a format that the Oracle can understand, and specify the format (i.e. data structure) of the answers you would like to receive - so that the community can answer them more reliably. The TellorX network is open to everyone, and Telliot is just one way to access it. You can use all of Telliot, parts of it, or not use it at all. You can also make contributions to improve it. Warning Use Telliot at your own risk. It may have bugs! Bugs may cost you real money! If you find any, please submit an issue , or better yet create a pull request with a suggested fix.","title":"Scope"},{"location":"contributing/","text":"Environment Setup \u00b6 Clone the repository: git clone https://github.com/tellor-io/pytelliot.git Create a virtual environment: python -m venv env Activate the virtual environment Linux Windows source env/bin/activate .\\venv\\Scripts\\activate.bat Install dependencies and project pip install -r requirements-dev.txt pip install -e . Verify Environment \u00b6 Run pytest to make sure that all tests pass: pytest Contributing \u00b6 Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run tests: pytest Check typing: mypy src --strict --implicit-reexport --ignore-missing-imports --disable-error-code misc Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #pytelliot channel in the community discord for updates.","title":"Developer's Guide"},{"location":"contributing/#environment-setup","text":"Clone the repository: git clone https://github.com/tellor-io/pytelliot.git Create a virtual environment: python -m venv env Activate the virtual environment Linux Windows source env/bin/activate .\\venv\\Scripts\\activate.bat Install dependencies and project pip install -r requirements-dev.txt pip install -e .","title":"Environment Setup"},{"location":"contributing/#verify-environment","text":"Run pytest to make sure that all tests pass: pytest","title":"Verify Environment"},{"location":"contributing/#contributing","text":"Once your dev environment is set up, make desired changes, create new tests for those changes, and conform to the style & typing format of the project. To do so, in the project home directory: Run tests: pytest Check typing: mypy src --strict --implicit-reexport --ignore-missing-imports --disable-error-code misc Check style (you may need run this step several times): tox -e style Once all those pass, you're ready to make a pull request to the project's main branch. Link any related issues, tag desired reviewers, and watch the #pytelliot channel in the community discord for updates.","title":"Contributing"},{"location":"documentation/","text":"Project Documentation \u00b6 PyTelliot is documented using Material for MkDocs . The latest documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve","title":"Documentation"},{"location":"documentation/#project-documentation","text":"PyTelliot is documented using Material for MkDocs . The latest documentation can be found here To compile and view local changes to documentation, use the following command, then open a browser to the link displayed: mkdocs serve","title":"Project Documentation"},{"location":"getting-started/","text":"Getting Started (Work In Progress) \u00b6 TODO","title":"Getting started"},{"location":"getting-started/#getting-started-work-in-progress","text":"TODO","title":"Getting Started (Work In Progress)"},{"location":"code/datafeed/","text":"DataFeed ( DataSourceDb , ABC ) pydantic-model \u00b6 Data feed A data feed creates a response value for an :class: ~telliot.queries.query.OracleQuery . update_sources ( self ) async \u00b6 Update data feed sources Returns: Type Description Dict[str, telliot.datafeed.data_source.TimeStampedAnswer[Any]] Dictionary of updated source values, mapping data source UID to the time-stamped answer for that data source Source code in telliot\\datafeed\\data_feed.py async def update_sources ( self ) -> Dict [ str , TimeStampedAnswer [ Any ]]: \"\"\"Update data feed sources Returns: Dictionary of updated source values, mapping data source UID to the time-stamped answer for that data source \"\"\" async def gather_inputs () -> Dict [ str , TimeStampedAnswer [ Any ]]: keys = self . sources . keys () values = await asyncio . gather ( * [ self . sources [ key ] . update_value () for key in keys ] ) return dict ( zip ( keys , values )) return await gather_inputs () DataSource ( Base , ABC ) pydantic-model \u00b6 Base Class for a DataSource. A DataSource provides an input to a DataFeed update_value ( self , store = False ) async \u00b6 Update current value with time-stamped value fetched from source Parameters: Name Type Description Default store bool If true and applicable, updated value will be stored to the database False Returns: Type Description Optional[telliot.datafeed.data_source.TimeStampedAnswer[Any]] Current time-stamped value Source code in telliot\\datafeed\\data_source.py @abstractmethod async def update_value ( self , store : bool = False ) -> Optional [ TimeStampedAnswer [ Any ]]: \"\"\"Update current value with time-stamped value fetched from source Args: store: If true and applicable, updated value will be stored to the database Returns: Current time-stamped value \"\"\" raise NotImplementedError DataSourceDb ( DataSource , ABC ) pydantic-model \u00b6 A data source that can store and retrieve values from a database load_value ( self ) async \u00b6 Update current value with time-stamped value fetched from database Source code in telliot\\datafeed\\data_source.py async def load_value ( self ) -> TimeStampedAnswer [ Any ]: \"\"\"Update current value with time-stamped value fetched from database\"\"\" raise NotImplementedError store_value ( self ) async \u00b6 Store current time-stamped value to database Source code in telliot\\datafeed\\data_source.py async def store_value ( self ) -> None : \"\"\"Store current time-stamped value to database\"\"\" value = self . value . val if self . value else None timestamp = str ( self . value . ts ) if self . value else None data = { \"uid\" : self . uid , \"value\" : value , \"timestamp\" : timestamp } url = \"http://127.0.0.1:8000/data/\" def store () -> Dict [ str , Any ]: \"\"\"Send post request to local db.\"\"\" with requests . Session () as s : try : r = s . post ( url , json = data ) json_data = r . json () return { \"response\" : json_data } except requests . exceptions . ConnectTimeout as e : return { \"error\" : \"Timeout Error\" , \"exception\" : e } except Exception as e : return { \"error\" : str ( type ( e )), \"exception\" : e } _ = store () get_history ( self , n = 0 ) async \u00b6 Get data source history from database Parameters: Name Type Description Default n int If n > 0, get n datapoints from database, otherwise get all available datapoints. 0 Returns: Type Description List[telliot.datafeed.data_source.TimeStampedAnswer[Any]] History of timestamped values from database Source code in telliot\\datafeed\\data_source.py @abstractmethod async def get_history ( self , n : int = 0 ) -> List [ TimeStampedAnswer [ Any ]]: \"\"\"Get data source history from database Args: n: If n > 0, get n datapoints from database, otherwise get all available datapoints. Returns: History of timestamped values from database \"\"\" raise NotImplementedError","title":"Data Feed Module"},{"location":"code/datafeed/#telliot.datafeed.data_feed.DataFeed","text":"Data feed A data feed creates a response value for an :class: ~telliot.queries.query.OracleQuery .","title":"DataFeed"},{"location":"code/datafeed/#telliot.datafeed.data_feed.DataFeed.update_sources","text":"Update data feed sources Returns: Type Description Dict[str, telliot.datafeed.data_source.TimeStampedAnswer[Any]] Dictionary of updated source values, mapping data source UID to the time-stamped answer for that data source Source code in telliot\\datafeed\\data_feed.py async def update_sources ( self ) -> Dict [ str , TimeStampedAnswer [ Any ]]: \"\"\"Update data feed sources Returns: Dictionary of updated source values, mapping data source UID to the time-stamped answer for that data source \"\"\" async def gather_inputs () -> Dict [ str , TimeStampedAnswer [ Any ]]: keys = self . sources . keys () values = await asyncio . gather ( * [ self . sources [ key ] . update_value () for key in keys ] ) return dict ( zip ( keys , values )) return await gather_inputs ()","title":"update_sources()"},{"location":"code/datafeed/#telliot.datafeed.data_source.DataSource","text":"Base Class for a DataSource. A DataSource provides an input to a DataFeed","title":"DataSource"},{"location":"code/datafeed/#telliot.datafeed.data_source.DataSource.update_value","text":"Update current value with time-stamped value fetched from source Parameters: Name Type Description Default store bool If true and applicable, updated value will be stored to the database False Returns: Type Description Optional[telliot.datafeed.data_source.TimeStampedAnswer[Any]] Current time-stamped value Source code in telliot\\datafeed\\data_source.py @abstractmethod async def update_value ( self , store : bool = False ) -> Optional [ TimeStampedAnswer [ Any ]]: \"\"\"Update current value with time-stamped value fetched from source Args: store: If true and applicable, updated value will be stored to the database Returns: Current time-stamped value \"\"\" raise NotImplementedError","title":"update_value()"},{"location":"code/datafeed/#telliot.datafeed.data_source.DataSourceDb","text":"A data source that can store and retrieve values from a database","title":"DataSourceDb"},{"location":"code/datafeed/#telliot.datafeed.data_source.DataSourceDb.load_value","text":"Update current value with time-stamped value fetched from database Source code in telliot\\datafeed\\data_source.py async def load_value ( self ) -> TimeStampedAnswer [ Any ]: \"\"\"Update current value with time-stamped value fetched from database\"\"\" raise NotImplementedError","title":"load_value()"},{"location":"code/datafeed/#telliot.datafeed.data_source.DataSourceDb.store_value","text":"Store current time-stamped value to database Source code in telliot\\datafeed\\data_source.py async def store_value ( self ) -> None : \"\"\"Store current time-stamped value to database\"\"\" value = self . value . val if self . value else None timestamp = str ( self . value . ts ) if self . value else None data = { \"uid\" : self . uid , \"value\" : value , \"timestamp\" : timestamp } url = \"http://127.0.0.1:8000/data/\" def store () -> Dict [ str , Any ]: \"\"\"Send post request to local db.\"\"\" with requests . Session () as s : try : r = s . post ( url , json = data ) json_data = r . json () return { \"response\" : json_data } except requests . exceptions . ConnectTimeout as e : return { \"error\" : \"Timeout Error\" , \"exception\" : e } except Exception as e : return { \"error\" : str ( type ( e )), \"exception\" : e } _ = store ()","title":"store_value()"},{"location":"code/datafeed/#telliot.datafeed.data_source.DataSourceDb.get_history","text":"Get data source history from database Parameters: Name Type Description Default n int If n > 0, get n datapoints from database, otherwise get all available datapoints. 0 Returns: Type Description List[telliot.datafeed.data_source.TimeStampedAnswer[Any]] History of timestamped values from database Source code in telliot\\datafeed\\data_source.py @abstractmethod async def get_history ( self , n : int = 0 ) -> List [ TimeStampedAnswer [ Any ]]: \"\"\"Get data source history from database Args: n: If n > 0, get n datapoints from database, otherwise get all available datapoints. Returns: History of timestamped values from database \"\"\" raise NotImplementedError","title":"get_history()"},{"location":"code/queries/","text":"OracleQuery ( SerializableModel ) pydantic-model \u00b6 Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent an input that can be used to customize the query. The base class provides: Calculation of the contents of the data field to include with the TellorX.Oracle.tipQuery() contract call. Calculation of the id field field to include with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. WORK IN PROGRESS - Descriptor formats still under development descriptor : str property readonly \u00b6 Get the query descriptor string. The Query descriptor is a unique string representation of the query. The descriptor is required for users to specify the query to TellorX through the TellorX.Oracle.tipQuery() contract call. By convention, the descriptor includes the text representation of the OracleQuery and the :class: ValueType of its response. `query` ? `value_type` value_type : ValueType property readonly \u00b6 Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be overridden by subclasses query_data : bytes property readonly \u00b6 Returns the data field for use in TellorX.Oracle.tipQuery() contract call. query_id : bytes property readonly \u00b6 Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. json ( self , ** kwargs ) \u00b6 Convert to compact JSON format used in query descriptor Source code in telliot\\queries\\query.py def json ( self , ** kwargs : Any ) -> str : \"\"\"Convert to compact JSON format used in query descriptor\"\"\" return super () . json ( ** kwargs , separators = ( \",\" , \":\" )) LegacyQuery ( OracleQuery ) pydantic-model \u00b6 Legacy Query Legacy queries are queries that existed prior to TellorX A legacy query uses arbitrary query data and a static query id . The query id is always set to the legacy request ID, which is an integer less than 100. The LegacyQuery class is deprecated and should not be used by new projects. Instead, use the CoinPrice query or create a new query. Refer to tellor documentation for a description of each id value_type : ValueType property readonly \u00b6 Returns the Legacy Value Type for all legacy queries query_id : bytes property readonly \u00b6 Override query id with the legacy request ID. must_be_less_than_100 ( v ) classmethod \u00b6 Validator to ensure that legacy request ID is less than or equal to 100. Source code in telliot\\queries\\legacy_query.py @validator ( \"legacy_request_id\" ) def must_be_less_than_100 ( cls , v ): # type: ignore \"\"\"Validator to ensure that legacy request ID is less than or equal to 100. \"\"\" if v is not None : if v > 100 : raise ValueError ( \"Legacy request ID must be less than 100\" ) return v CoinPrice ( OracleQuery ) pydantic-model \u00b6 Query the price of a cryptocurrency coin. Attributes: Name Type Description coin str Token symbol currency str Price currency symbol (default = USD) price_type Literal['current', 'eod', '24hr_twap', '1hr_twap', 'custom', 'manual'] Price Type (default = current) value_type : ValueType property readonly \u00b6 Returns the fixed value type for a CoinPrice. asset_must_be_lower_case ( v ) classmethod \u00b6 A validator to force coin to lower case Source code in telliot\\queries\\coin_price.py @validator ( \"coin\" ) def asset_must_be_lower_case ( cls , v : str ) -> str : \"\"\"A validator to force coin to lower case\"\"\" return v . lower () currency_must_be_lower_case ( v ) classmethod \u00b6 A validator to force the currency lower case Source code in telliot\\queries\\coin_price.py @validator ( \"currency\" ) def currency_must_be_lower_case ( cls , v : str ) -> str : \"\"\"A validator to force the currency lower case\"\"\" return v . lower () StringQuery ( OracleQuery ) pydantic-model \u00b6 Static Oracle Query A text query supports a question in the form of an arbitrary text. value_type : ValueType property readonly \u00b6 Returns a default text response type.","title":"Queries Module"},{"location":"code/queries/#telliot.queries.query.OracleQuery","text":"Oracle Query An OracleQuery specifies how to pose a question to the Tellor Oracle and how to format/interpret the response. The OracleQuery class serves as the base class for all Queries, and implements default behaviors. Each subclass corresponds to a unique Query Type supported by the TellorX network. All public attributes of an OracleQuery represent an input that can be used to customize the query. The base class provides: Calculation of the contents of the data field to include with the TellorX.Oracle.tipQuery() contract call. Calculation of the id field field to include with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls. WORK IN PROGRESS - Descriptor formats still under development","title":"OracleQuery"},{"location":"code/queries/#telliot.queries.query.OracleQuery.descriptor","text":"Get the query descriptor string. The Query descriptor is a unique string representation of the query. The descriptor is required for users to specify the query to TellorX through the TellorX.Oracle.tipQuery() contract call. By convention, the descriptor includes the text representation of the OracleQuery and the :class: ValueType of its response. `query` ? `value_type`","title":"descriptor"},{"location":"code/queries/#telliot.queries.query.OracleQuery.value_type","text":"Returns the ValueType expected by the current Query configuration The value type defines required data type/structure of the value submitted to the contract through TellorX.Oracle.submitValue() This method must be overridden by subclasses","title":"value_type"},{"location":"code/queries/#telliot.queries.query.OracleQuery.query_data","text":"Returns the data field for use in TellorX.Oracle.tipQuery() contract call.","title":"query_data"},{"location":"code/queries/#telliot.queries.query.OracleQuery.query_id","text":"Returns the query id for use with the TellorX.Oracle.tipQuery() and TellorX.Oracle.submitValue() contract calls.","title":"query_id"},{"location":"code/queries/#telliot.queries.query.OracleQuery.json","text":"Convert to compact JSON format used in query descriptor Source code in telliot\\queries\\query.py def json ( self , ** kwargs : Any ) -> str : \"\"\"Convert to compact JSON format used in query descriptor\"\"\" return super () . json ( ** kwargs , separators = ( \",\" , \":\" ))","title":"json()"},{"location":"code/queries/#telliot.queries.legacy_query.LegacyQuery","text":"Legacy Query Legacy queries are queries that existed prior to TellorX A legacy query uses arbitrary query data and a static query id . The query id is always set to the legacy request ID, which is an integer less than 100. The LegacyQuery class is deprecated and should not be used by new projects. Instead, use the CoinPrice query or create a new query. Refer to tellor documentation for a description of each id","title":"LegacyQuery"},{"location":"code/queries/#telliot.queries.legacy_query.LegacyQuery.value_type","text":"Returns the Legacy Value Type for all legacy queries","title":"value_type"},{"location":"code/queries/#telliot.queries.legacy_query.LegacyQuery.query_id","text":"Override query id with the legacy request ID.","title":"query_id"},{"location":"code/queries/#telliot.queries.legacy_query.LegacyQuery.must_be_less_than_100","text":"Validator to ensure that legacy request ID is less than or equal to 100. Source code in telliot\\queries\\legacy_query.py @validator ( \"legacy_request_id\" ) def must_be_less_than_100 ( cls , v ): # type: ignore \"\"\"Validator to ensure that legacy request ID is less than or equal to 100. \"\"\" if v is not None : if v > 100 : raise ValueError ( \"Legacy request ID must be less than 100\" ) return v","title":"must_be_less_than_100()"},{"location":"code/queries/#telliot.queries.coin_price.CoinPrice","text":"Query the price of a cryptocurrency coin. Attributes: Name Type Description coin str Token symbol currency str Price currency symbol (default = USD) price_type Literal['current', 'eod', '24hr_twap', '1hr_twap', 'custom', 'manual'] Price Type (default = current)","title":"CoinPrice"},{"location":"code/queries/#telliot.queries.coin_price.CoinPrice.value_type","text":"Returns the fixed value type for a CoinPrice.","title":"value_type"},{"location":"code/queries/#telliot.queries.coin_price.CoinPrice.asset_must_be_lower_case","text":"A validator to force coin to lower case Source code in telliot\\queries\\coin_price.py @validator ( \"coin\" ) def asset_must_be_lower_case ( cls , v : str ) -> str : \"\"\"A validator to force coin to lower case\"\"\" return v . lower ()","title":"asset_must_be_lower_case()"},{"location":"code/queries/#telliot.queries.coin_price.CoinPrice.currency_must_be_lower_case","text":"A validator to force the currency lower case Source code in telliot\\queries\\coin_price.py @validator ( \"currency\" ) def currency_must_be_lower_case ( cls , v : str ) -> str : \"\"\"A validator to force the currency lower case\"\"\" return v . lower ()","title":"currency_must_be_lower_case()"},{"location":"code/queries/#telliot.queries.string_query.StringQuery","text":"Static Oracle Query A text query supports a question in the form of an arbitrary text.","title":"StringQuery"},{"location":"code/queries/#telliot.queries.string_query.StringQuery.value_type","text":"Returns a default text response type.","title":"value_type"},{"location":"code/types/","text":"ValueType ( SerializableModel ) pydantic-model \u00b6 Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html encode ( self , value ) \u00b6 Encode a value using the ABI Type string. Source code in telliot\\types\\value_type.py def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value ) decode ( self , bytes_val ) \u00b6 Decode bytes into a value using abi type string. Source code in telliot\\types\\value_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val ) require_valid_grammar ( v ) classmethod \u00b6 A validator to require well formed ABI type string grammar. Source code in telliot\\types\\value_type.py @validator ( \"abi_type\" ) def require_valid_grammar ( cls , v : str ) -> str : \"\"\"A validator to require well formed ABI type string grammar.\"\"\" t = eth_abi . grammar . parse ( v ) t . validate () return eth_abi . grammar . normalize ( v ) # type: ignore json ( self , ** kwargs ) \u00b6 Return compact json format used in query descriptor Source code in telliot\\types\\value_type.py def json ( self , ** kwargs : Any ) -> str : \"\"\"Return compact json format used in query descriptor\"\"\" return super () . json ( ** kwargs , separators = ( \",\" , \":\" )) UnsignedFloatType ( ValueType ) pydantic-model \u00b6 Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values. decimals : int property readonly \u00b6 Get precision from abi type nbits : int property readonly \u00b6 Get number of bits from abi type encode ( self , value ) \u00b6 An encoder for float values This encoder converts a float value to the CoinPrice ABI data type. Source code in telliot\\types\\float_type.py def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the CoinPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value ) decode ( self , bytes_val ) \u00b6 A decoder for float values This decoder converts from the CoinPrice ABI data type to a floating point value. Source code in telliot\\types\\float_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the CoinPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals require_ufixed_abi_type ( v ) classmethod \u00b6 Validator to require a ufixed abi type Source code in telliot\\types\\float_type.py @validator ( \"abi_type\" ) def require_ufixed_abi_type ( cls , v : str ) -> str : \"\"\"Validator to require a ufixed abi type\"\"\" if v [: 6 ] != \"ufixed\" : raise ValueError ( \"Abi Type must be ufixedMxN\" ) return v . lower ()","title":"Types Module"},{"location":"code/types/#telliot.types.value_type.ValueType","text":"Value Type A ValueType specifies the data structure of value included in the TellorX.Oracle.submitValue() used in response to tip request. The type is specified per eth-abi grammar, i.e. https://eth-abi.readthedocs.io/en/latest/grammar.html","title":"ValueType"},{"location":"code/types/#telliot.types.value_type.ValueType.encode","text":"Encode a value using the ABI Type string. Source code in telliot\\types\\value_type.py def encode ( self , value : Any ) -> bytes : \"\"\"Encode a value using the ABI Type string.\"\"\" if self . packed : return encode_single_packed ( self . abi_type , value ) else : return encode_single ( self . abi_type , value )","title":"encode()"},{"location":"code/types/#telliot.types.value_type.ValueType.decode","text":"Decode bytes into a value using abi type string. Source code in telliot\\types\\value_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"Decode bytes into a value using abi type string.\"\"\" return decode_single ( self . abi_type , bytes_val )","title":"decode()"},{"location":"code/types/#telliot.types.value_type.ValueType.require_valid_grammar","text":"A validator to require well formed ABI type string grammar. Source code in telliot\\types\\value_type.py @validator ( \"abi_type\" ) def require_valid_grammar ( cls , v : str ) -> str : \"\"\"A validator to require well formed ABI type string grammar.\"\"\" t = eth_abi . grammar . parse ( v ) t . validate () return eth_abi . grammar . normalize ( v ) # type: ignore","title":"require_valid_grammar()"},{"location":"code/types/#telliot.types.value_type.ValueType.json","text":"Return compact json format used in query descriptor Source code in telliot\\types\\value_type.py def json ( self , ** kwargs : Any ) -> str : \"\"\"Return compact json format used in query descriptor\"\"\" return super () . json ( ** kwargs , separators = ( \",\" , \":\" ))","title":"json()"},{"location":"code/types/#telliot.types.float_type.UnsignedFloatType","text":"Unsigned Float Type This class specifies the a floating point value using an ABI data type. It also provides encoding/decoding to/from floating point values.","title":"UnsignedFloatType"},{"location":"code/types/#telliot.types.float_type.UnsignedFloatType.decimals","text":"Get precision from abi type","title":"decimals"},{"location":"code/types/#telliot.types.float_type.UnsignedFloatType.nbits","text":"Get number of bits from abi type","title":"nbits"},{"location":"code/types/#telliot.types.float_type.UnsignedFloatType.encode","text":"An encoder for float values This encoder converts a float value to the CoinPrice ABI data type. Source code in telliot\\types\\float_type.py def encode ( self , value : float ) -> bytes : \"\"\"An encoder for float values This encoder converts a float value to the CoinPrice ABI data type. \"\"\" decimal_value = Decimal ( value ) . quantize ( Decimal ( 10 ) ** - self . decimals ) return super () . encode ( decimal_value )","title":"encode()"},{"location":"code/types/#telliot.types.float_type.UnsignedFloatType.decode","text":"A decoder for float values This decoder converts from the CoinPrice ABI data type to a floating point value. Source code in telliot\\types\\float_type.py def decode ( self , bytes_val : bytes ) -> Any : \"\"\"A decoder for float values This decoder converts from the CoinPrice ABI data type to a floating point value. \"\"\" nbytes = self . nbits / 8 if self . packed : if len ( bytes_val ) != nbytes : raise ValueError ( f \"Value must be { nbytes } bytes\" ) intval = int . from_bytes ( bytes_val , \"big\" , signed = False ) return intval / 10.0 ** self . decimals","title":"decode()"},{"location":"code/types/#telliot.types.float_type.UnsignedFloatType.require_ufixed_abi_type","text":"Validator to require a ufixed abi type Source code in telliot\\types\\float_type.py @validator ( \"abi_type\" ) def require_ufixed_abi_type ( cls , v : str ) -> str : \"\"\"Validator to require a ufixed abi type\"\"\" if v [: 6 ] != \"ufixed\" : raise ValueError ( \"Abi Type must be ufixedMxN\" ) return v . lower ()","title":"require_ufixed_abi_type()"},{"location":"examples/legacy_query_example/","text":"Legacy Query Example \u00b6 The following example demonstrates how to create a LegacyQuery requesting the ETH/USD price. The legacy request ID for ETH/USD is 1 , in accordance with the Legacy Data Feed ID Specifications . Create a LegacyQuery and view the corresponding query descriptor: \"\"\"Legacy Query Example \"\"\" from telliot.queries import LegacyQuery q = LegacyQuery ( legacy_request_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"LegacyQuery\" , \"inputs\" :{ \"legacy_request_id\" : 1 }} ? { \"type\" : \"UnsignedFloatType\" , \"inputs\" :{ \"abi_type\" : \"ufixed256x6\" , \"packed\" : false }} To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the LegacyQuery object: \"\"\"Legacy Query Example \"\"\" from telliot.queries import LegacyQuery q = LegacyQuery ( legacy_request_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a224c65676163795175657279222c22696e70757473223a7b226c65676163795f726571756573745f6964223a317d7d3f7b2274797065223a22556e7369676e6564466c6f617454797065222c22696e70757473223a7b226162695f74797065223a227566697865643235367836222c227061636b6564223a66616c73657d7d tipQuery ID: 0x0000000000000000000000000000000000000000000000000000000000000001 The LegacyQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the value 10000.1234567 , use the encode and decode methods of the response ValueType . \"\"\"Legacy Query Example \"\"\" from telliot.queries import LegacyQuery q = LegacyQuery ( legacy_request_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (float): 10000.1234567 submitValue (bytes): 0x00000000000000000000000000000000000000000000000000000002540dc641 Decoded value (float): 10000.123457","title":"Legacy Query"},{"location":"examples/legacy_query_example/#legacy-query-example","text":"The following example demonstrates how to create a LegacyQuery requesting the ETH/USD price. The legacy request ID for ETH/USD is 1 , in accordance with the Legacy Data Feed ID Specifications . Create a LegacyQuery and view the corresponding query descriptor: \"\"\"Legacy Query Example \"\"\" from telliot.queries import LegacyQuery q = LegacyQuery ( legacy_request_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"LegacyQuery\" , \"inputs\" :{ \"legacy_request_id\" : 1 }} ? { \"type\" : \"UnsignedFloatType\" , \"inputs\" :{ \"abi_type\" : \"ufixed256x6\" , \"packed\" : false }} To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the LegacyQuery object: \"\"\"Legacy Query Example \"\"\" from telliot.queries import LegacyQuery q = LegacyQuery ( legacy_request_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a224c65676163795175657279222c22696e70757473223a7b226c65676163795f726571756573745f6964223a317d7d3f7b2274797065223a22556e7369676e6564466c6f617454797065222c22696e70757473223a7b226162695f74797065223a227566697865643235367836222c227061636b6564223a66616c73657d7d tipQuery ID: 0x0000000000000000000000000000000000000000000000000000000000000001 The LegacyQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit the value 10000.1234567 , use the encode and decode methods of the response ValueType . \"\"\"Legacy Query Example \"\"\" from telliot.queries import LegacyQuery q = LegacyQuery ( legacy_request_id = 1 ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = 10000.1234567 print ( f \"submitValue (float): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (float): 10000.1234567 submitValue (bytes): 0x00000000000000000000000000000000000000000000000000000002540dc641 Decoded value (float): 10000.123457","title":"Legacy Query Example"},{"location":"examples/text_query_example/","text":"Text Query Example \u00b6 The following example demonstrates how to create a StringQuery request. Create a StringQuery and view the corresponding query descriptor:: \"\"\"Text Query Example \"\"\" from telliot.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"StringQuery\" , \"inputs\" :{ \"text\" : \"What is the meaning of life?\" }} ? { \"type\" : \"ValueType\" , \"inputs\" :{ \"abi_type\" : \"string\" , \"packed\" : false }} To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the StringQuery object: \"\"\"Text Query Example \"\"\" from telliot.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a22537472696e675175657279222c22696e70757473223a7b2274657874223a225768617420697320746865206d65616e696e67206f66206c6966653f227d7d3f7b2274797065223a2256616c756554797065222c22696e70757473223a7b226162695f74797065223a22737472696e67222c227061636b6564223a66616c73657d7d tipQuery ID: 0xdd349fc565b13987a11bed4cc9e7382863491638769020afad1abe3840ec14b7 The StringQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit following the answer Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life use the encode and decode methods of the response ValueType . \"\"\"Text Query Example \"\"\" from telliot.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (str): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life submitValue (bytes): 0x000000000000000000000000000000000000000000000000000000000000003e506c6561736520726566657220746f3a2068747470733a2f2f656e2e77696b6970656469612e6f72672f77696b692f4d65616e696e675f6f665f6c6966650000 Decoded value (float): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life","title":"Text Query"},{"location":"examples/text_query_example/#text-query-example","text":"The following example demonstrates how to create a StringQuery request. Create a StringQuery and view the corresponding query descriptor:: \"\"\"Text Query Example \"\"\" from telliot.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) The query descriptor string uniquely identifies this query to the TellorX Oracle network. { \"type\" : \"StringQuery\" , \"inputs\" :{ \"text\" : \"What is the meaning of life?\" }} ? { \"type\" : \"ValueType\" , \"inputs\" :{ \"abi_type\" : \"string\" , \"packed\" : false }} To make the corresponding on-chain Query request, the TellorX.Oracle.tipQuery() contract call requires two arguments: queryData and queryId . These arguments are provided by the query_data and query_id attributes of the StringQuery object: \"\"\"Text Query Example \"\"\" from telliot.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) which, for this example, are: tipQuery data: 0x7b2274797065223a22537472696e675175657279222c22696e70757473223a7b2274657874223a225768617420697320746865206d65616e696e67206f66206c6966653f227d7d3f7b2274797065223a2256616c756554797065222c22696e70757473223a7b226162695f74797065223a22737472696e67222c227061636b6564223a66616c73657d7d tipQuery ID: 0xdd349fc565b13987a11bed4cc9e7382863491638769020afad1abe3840ec14b7 The StringQuery object also demonstrates how to encode a response to submit on-chain using the TellorX.Oracle.submitValue() contract call. For example, to submit following the answer Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life use the encode and decode methods of the response ValueType . \"\"\"Text Query Example \"\"\" from telliot.queries import StringQuery q = StringQuery ( text = \"What is the meaning of life?\" ) print ( q . descriptor ) print ( f \"tipQuery data: 0x { q . query_data . hex () } \" ) print ( f \"tipQuery ID: 0x { q . query_id . hex () } \" ) value = \"Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life\" print ( f \"submitValue (str): { value } \" ) encoded_bytes = q . value_type . encode ( value ) print ( f \"submitValue (bytes): 0x { encoded_bytes . hex () } \" ) decoded_value = q . value_type . decode ( encoded_bytes ) print ( f \"Decoded value (float): { decoded_value } \" ) Note that the on-chain and decoded values are limited to 6 decimals of precision in accordance with the on-chain data type: submitValue (str): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life submitValue (bytes): 0x000000000000000000000000000000000000000000000000000000000000003e506c6561736520726566657220746f3a2068747470733a2f2f656e2e77696b6970656469612e6f72672f77696b692f4d65616e696e675f6f665f6c6966650000 Decoded value (float): Please refer to: https://en.wikipedia.org/wiki/Meaning_of_life","title":"Text Query Example"}]}